<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pattern Avoidance - 극한의 정밀 컨트롤</title>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4133279395991822" crossorigin="anonymous"></script>
    <style>
        :root { --bg: #0c0c0c; --point: #f1c40f; --danger: #e74c3c; --text: #ffffff; --card: #1a1a1a; }
        body { margin: 0; background: var(--bg); color: var(--text); font-family: 'Pretendard', sans-serif; overflow-x: hidden; display: flex; flex-direction: column; align-items: center; }
        
        header { width: 100%; height: 65px; background: #000; border-bottom: 1px solid #333; display: flex; align-items: center; justify-content: space-between; padding: 0 30px; box-sizing: border-box; position: sticky; top: 0; z-index: 1000; }
        .btn-hub { padding: 10px 20px; background: transparent; color: var(--point); text-decoration: none; font-weight: bold; border: 2px solid var(--point); border-radius: 5px; transition: 0.3s; font-size: 14px; }
        .btn-hub:hover { background: var(--point); color: #000; }

        #game-container { position: relative; width: 100%; min-height: 650px; display: flex; justify-content: center; align-items: center; flex-direction: column; margin-top: 20px; }
        canvas { background: #000; border: 4px solid #fff; display: none; box-shadow: 0 0 25px rgba(255, 255, 255, 0.1); }

        .overlay { text-align: center; background: var(--card); padding: 40px; border-radius: 20px; border: 1px solid #333; min-width: 350px; }
        #start-screen, #result-screen { display: flex; flex-direction: column; align-items: center; gap: 20px; }
        
        .difficulty-container { display: flex; gap: 15px; width: 100%; margin-top: 10px; }
        .btn-diff { padding: 12px 30px; font-size: 18px; border: none; cursor: pointer; font-weight: bold; border-radius: 8px; transition: 0.2s; flex: 1; }
        .btn-easy { background: #2ecc71; color: #000; }
        .btn-hard { background: var(--danger); color: #fff; }
        
        input { padding: 15px; font-size: 18px; border-radius: 8px; border: 1px solid #444; background: #000; color: #fff; width: 250px; text-align: center; margin-bottom: 10px; }
        .btn-main { padding: 15px 60px; font-size: 20px; background: var(--point); border: none; cursor: pointer; font-weight: bold; border-radius: 8px; transition: 0.2s; color: #000; }

        #status-ui { width: 400px; display: none; justify-content: space-between; font-size: 16px; font-weight: bold; margin-bottom: 10px; position: relative; }
        #level-up-msg { position: absolute; right: -130px; color: var(--point); animation: blink 0.5s infinite; display: none; }
        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }

        #seo-content { width: 90%; max-width: 900px; padding: 60px 0; color: #777; line-height: 1.9; }
        .seo-box { background: #111; padding: 25px; border-radius: 10px; border-left: 4px solid var(--point); margin-bottom: 25px; }
        .seo-box h3 { color: var(--point); margin-top: 0; }
        .seo-box p { margin-bottom: 15px; }
        #version-tag { position: fixed; bottom: 10px; right: 10px; font-size: 12px; color: #333; }
    </style>
</head>
<body>

    <header>
        <div style="font-size: 20px; font-weight: 900; letter-spacing: 1px;">PATTERN <span style="color: var(--point);">AVOIDANCE</span></div>
        <a href="https://game-hub-steel-eight.vercel.app/" class="btn-hub">← GAME HUB 돌아가기</a>
    </header>

    <div id="game-container">
        <div id="start-screen" class="overlay">
            <h1 style="font-size: 2.2rem; margin: 0;">난이도 선택</h1>
            <p style="color: #aaa;">BGM 추가 완료! 궤도 추적 및 속도 2.0</p>
            <div class="difficulty-container">
                <button class="btn-diff btn-easy" onclick="startGame('EASY')">EASY<br><span style="font-size:11px;">HP 15</span></button>
                <button class="btn-diff btn-hard" onclick="startGame('HARD')">HARD<br><span style="font-size:11px;">HP 3 (HELL)</span></button>
            </div>
            <p style="font-size: 14px; color: #555; margin-top: 15px;">조작: WASD | 중단: ESC</p>
        </div>

        <div id="result-screen" class="overlay" style="display:none;">
            <h2 style="color: var(--danger); margin: 0;">GAME OVER</h2>
            <h1 id="result-time" style="font-size: 3.5rem; color: var(--point); margin: 10px 0;">0.0s</h1>
            <div id="save-form">
                <input type="text" id="username" placeholder="이름 (미입력 시 익명)" maxlength="10">
                <br>
                <button class="btn-main" id="save-btn" onclick="saveRecord()">기록 저장</button>
            </div>
            <button class="btn-main" onclick="location.reload()" style="display:none; background: #333; color: #fff; margin-top: 10px;" id="retry-btn">다시 시도</button>
        </div>

        <div id="status-ui">
            <div id="ui-diff-label">MODE: EASY</div>
            <div style="color:var(--danger)">HP: <span id="hp-val">15</span></div>
            <div id="ui-timer" style="color: var(--point);">0.0s</div>
            <div id="level-up-msg">LEVEL UP!</div>
        </div>
        <canvas id="gameCanvas" width="400" height="400"></canvas>
    </div>

    <section id="seo-content">
        <div class="seo-box">
            <h3>패턴 피하기(Pattern Avoidance) v1.1.14: 게임 마스터 가이드</h3>
            <p>본 게임은 게이머의 미세 무빙 역량과 시각적 예측 지능을 극한까지 끌어올리기 위해 제작되었습니다. 특히 이번 버전에서 고정된 <b>2.0의 낮은 이동 속도</b>는 플레이어에게 빠른 반응보다는 '정확한 위치 선정'과 '패턴 읽기' 능력을 요구합니다. 무작위로 생성되는 탄막 사이에서 0.1mm의 오차도 허용하지 않는 정밀한 컨트롤을 연습해 보세요.</p>
            <p>이지 모드에서는 15의 넉넉한 체력으로 패턴의 메커니즘을 학습할 수 있으며, 하드 모드는 단 3회의 피격만으로 게임이 종료되는 지옥 같은 난이도를 제공합니다. 고득점을 위해서는 화면 중앙을 고수하기보다 외곽과 중앙을 유연하게 오가는 전략이 필수적입니다.</p>
        </div>
        <div class="seo-box">
            <h3>실시간 동적 난이도 및 듀얼 엔진 시스템</h3>
            <p>게임은 내부적으로 <b>레이저 생성 엔진</b>과 <b>추적 탄환 엔진</b>이 독립적으로 구동됩니다. 20초가 경과하면 화면을 사분할하는 '십자 레이저'가 등장하며, 40초 이후에는 대각선 전체를 타격하는 'X자 레이저'가 추가되어 안전 구역이 급격히 줄어듭니다. 또한 45초부터는 특정 지점에서 8방향으로 퍼져나가는 방사형 탄환이 추가되어 쉴 틈 없는 회피를 강요합니다.</p>
            <p>30초와 60초 생존 시에는 우측 상단에 'LEVEL UP!' 표시와 함께 모든 패턴의 생성 간격이 최대치로 가속화됩니다. 신나는 비트의 BGM과 함께 몰입감을 극대화하고, 전 세계 플레이어들과 실시간 랭킹 경쟁을 통해 당신의 피지컬을 증명하십시오.</p>
        </div>
        <div class="seo-box">
            <h3>시스템 업데이트 및 버그 수정 내역</h3>
            <p>v1.1.14 버전에서는 사용자 피드백을 반영하여 게임 중단(ESC) 시의 안정성을 강화하였습니다. 또한 추적 탄환 발사 전 플레이어를 실시간으로 조준하는 '궤도 점선'을 다시 활성화하여 전략적인 회피가 가능하도록 개선했습니다. 고품질의 8비트 사운드트랙은 플레이어의 집중력을 유지시켜주며, Firebase 연동을 통한 실시간 데이터 저장 시스템은 안정적인 기록 관리를 보장합니다.</p>
        </div>
    </section>

    <div id="version-tag">v1.1.14</div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getFirestore, collection, addDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCWvmTD7ZqrM8QS2jAtIoxyYw9zDghyyZo",
            authDomain: "dummy-server-ff1b9.firebaseapp.com",
            projectId: "dummy-server-ff1b9",
            storageBucket: "dummy-server-ff1b9.firebasestorage.app",
            messagingSenderId: "275700573811",
            appId: "1:275700573811:web:bb1290a5e5ec97a73cac06"
        };
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // BGM 설정
        const bgm = new Audio('https://orangefreesounds.com/wp-content/uploads/2014/10/8-bit-music-loop.mp3');
        bgm.loop = true;

        let gameState = 'WAIT', diffMode = 'EASY', animationId = null;
        let player = { x: 200, y: 200, r: 6, hp: 15, speed: 2.0 };
        let objects = [], keys = {}, startTime = 0, survivedTime = "0.0";
        let spawnTimers = [];

        window.addEventListener('keydown', (e) => { 
            keys[e.code] = true; 
            if(e.code === 'Escape' && (gameState === 'PLAY' || gameState === 'READY')) endGame(); 
        });
        window.addEventListener('keyup', (e) => { keys[e.code] = false; });

        window.startGame = function(mode) {
            diffMode = mode;
            player.hp = (mode === 'EASY') ? 15 : 3;
            document.getElementById('hp-val').innerText = player.hp;
            document.getElementById('ui-diff-label').innerText = 'MODE: ' + mode;
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('status-ui').style.display = 'flex';
            canvas.style.display = 'block';
            
            // BGM 재생 (사용자 상호작용 후 재생 가능)
            bgm.play().catch(e => console.log("BGM Play blocked"));
            
            startReady();
        }

        function startReady() {
            gameState = 'READY';
            let count = 3;
            let readyInt = setInterval(() => {
                if(gameState === 'END') { clearInterval(readyInt); return; }
                draw();
                ctx.fillStyle = "#f1c40f"; ctx.font = "bold 50px Pretendard"; ctx.textAlign = "center";
                ctx.fillText(count > 0 ? count : "GO!", 200, 220);
                if(count < 0) { 
                    clearInterval(readyInt); 
                    if(gameState !== 'END') {
                        gameState = 'PLAY'; startTime = Date.now(); 
                        spawnLaserLoop(); spawnHomingLoop(); gameLoop(); 
                    }
                }
                count--;
            }, 800);
        }

        function spawnLaserLoop() {
            if(gameState !== 'PLAY') return;
            const t = parseFloat(survivedTime);
            const rand = Math.random();
            if(t > 40 && rand < 0.3) spawnX();
            else if(t > 20 && rand < 0.5) spawnCross();
            else spawnLaser();
            let base = (diffMode === 'EASY') ? 800 : 500;
            let itv = Math.max(150, base - (t * 12));
            spawnTimers.push(setTimeout(spawnLaserLoop, itv));
        }

        function spawnHomingLoop() {
            if(gameState !== 'PLAY') return;
            const t = parseFloat(survivedTime);
            if(t > 45 && Math.random() < 0.4) spawnRadial();
            else spawnHoming();
            let base = (diffMode === 'EASY') ? 1200 : 700;
            let itv = Math.max(300, base - (t * 15));
            spawnTimers.push(setTimeout(spawnHomingLoop, itv));
        }

        function spawnLaser() { objects.push({ type: 'LASER', sub: Math.random()>0.5?'H':'V', pos: Math.random()*380+10, stage: 'WARN', timer: Date.now() }); }
        function spawnCross() { 
            objects.push({ type: 'LASER', sub: 'H', pos: player.y, stage: 'WARN', timer: Date.now(), thick: 25 });
            objects.push({ type: 'LASER', sub: 'V', pos: player.x, stage: 'WARN', timer: Date.now(), thick: 25 });
        }
        function spawnX() {
            objects.push({ type: 'LASER', sub: 'X1', stage: 'WARN', timer: Date.now() });
            objects.push({ type: 'LASER', sub: 'X2', stage: 'WARN', timer: Date.now() });
        }
        function spawnHoming() { objects.push({ type: 'HOMING', x: Math.random()*400, y: Math.random()*400, stage: 'WARN', timer: Date.now() }); }
        function spawnRadial() { objects.push({ type: 'RADIAL', x: 200, y: 200, stage: 'FIRE', timer: Date.now() }); }

        function update() {
            if(gameState !== 'PLAY') return;
            if(keys['KeyW'] && player.y > player.r) player.y -= player.speed;
            if(keys['KeyS'] && player.y < 400 - player.r) player.y += player.speed;
            if(keys['KeyA'] && player.x > player.r) player.x -= player.speed;
            if(keys['KeyD'] && player.x < 400 - player.r) player.x += player.speed;

            let prev = parseFloat(survivedTime);
            survivedTime = ((Date.now() - startTime) / 1000).toFixed(1);
            document.getElementById('ui-timer').innerText = survivedTime + 's';
            
            let cur = parseFloat(survivedTime);
            if((prev < 30 && cur >= 30) || (prev < 60 && cur >= 60)) {
                document.getElementById('level-up-msg').style.display = 'block';
                setTimeout(() => document.getElementById('level-up-msg').style.display = 'none', 3000);
            }

            const now = Date.now();
            for(let i = objects.length - 1; i >= 0; i--) {
                let o = objects[i];
                const warnDur = (diffMode === 'EASY') ? 700 : 500;
                if(o.stage === 'WARN' && now - o.timer > warnDur) {
                    o.stage = 'FIRE'; o.timer = now;
                    if(o.type === 'HOMING') {
                        const ang = Math.atan2(player.y - o.y, player.x - o.x);
                        o.vx = Math.cos(ang) * 5; o.vy = Math.sin(ang) * 5;
                    }
                    if(o.type === 'RADIAL') { 
                        o.bullets = []; for(let j=0; j<8; j++){ 
                            let a = (Math.PI*2/8)*j; o.bullets.push({x:o.x, y:o.y, vx:Math.cos(a)*3, vy:Math.sin(a)*3});
                        }
                    }
                } else if(o.stage === 'FIRE') {
                    let hit = false;
                    if(o.type === 'LASER') {
                        let t = o.thick || 15;
                        if(o.sub === 'H' && Math.abs(player.y - o.pos) < player.r + t/2) hit = true;
                        if(o.sub === 'V' && Math.abs(player.x - o.pos) < player.r + t/2) hit = true;
                        if(o.sub === 'X1' && Math.abs(player.x - player.y) < player.r + 10) hit = true;
                        if(o.sub === 'X2' && Math.abs(player.x + player.y - 400) < player.r + 10) hit = true;
                        if(now - o.timer > 200) objects.splice(i, 1);
                    } else if(o.type === 'HOMING') {
                        o.x += o.vx; o.y += o.vy;
                        if(Math.hypot(player.x-o.x, player.y-o.y) < player.r + 5) hit = true;
                        if(o.x<0 || o.x>400 || o.y<0 || o.y>400) objects.splice(i, 1);
                    } else if(o.type === 'RADIAL') {
                        o.bullets.forEach((b, bi) => {
                            b.x += b.vx; b.y += b.vy;
                            if(Math.hypot(player.x-b.x, player.y-b.y) < player.r + 4) { hit = true; o.bullets.splice(bi, 1); }
                        });
                        if(now - o.timer > 2000) objects.splice(i, 1);
                    }
                    if(hit) { player.hp--; document.getElementById('hp-val').innerText = player.hp; if(player.hp <= 0) endGame(); }
                }
            }
        }

        function draw() {
            ctx.fillStyle = "#000"; ctx.fillRect(0,0,400,400);
            ctx.beginPath(); ctx.arc(player.x, player.y, player.r, 0, Math.PI*2);
            ctx.fillStyle = "#e74c3c"; ctx.fill(); ctx.closePath();
            objects.forEach(o => {
                ctx.beginPath();
                if(o.type === 'LASER') {
                    if(o.stage === 'WARN') { ctx.strokeStyle = "rgba(241,196,15,0.3)"; ctx.lineWidth = 2; ctx.setLineDash([5,5]); }
                    else { ctx.strokeStyle = "#fff"; ctx.lineWidth = o.thick || 15; ctx.setLineDash([]); }
                    if(o.sub === 'H') { ctx.moveTo(0, o.pos); ctx.lineTo(400, o.pos); }
                    else if(o.sub === 'V') { ctx.moveTo(o.pos, 0); ctx.lineTo(o.pos, 400); }
                    else if(o.sub === 'X1') { ctx.moveTo(0,0); ctx.lineTo(400,400); }
                    else if(o.sub === 'X2') { ctx.moveTo(400,0); ctx.lineTo(0,400); }
                    ctx.stroke();
                } else if(o.type === 'HOMING') {
                    if(o.stage === 'WARN') { 
                        ctx.strokeStyle = "rgba(231,76,60,0.4)"; ctx.lineWidth = 1; ctx.setLineDash([2,4]);
                        ctx.moveTo(o.x, o.y); ctx.lineTo(player.x, player.y); ctx.stroke();
                        ctx.setLineDash([]);
                        ctx.fillStyle = "rgba(231,76,60,0.3)"; ctx.beginPath(); ctx.arc(o.x,o.y,4,0,Math.PI*2); ctx.fill(); 
                    } else { 
                        ctx.fillStyle = "#f1c40f"; ctx.beginPath(); ctx.arc(o.x,o.y,6,0,Math.PI*2); ctx.fill(); 
                    }
                } else if(o.type === 'RADIAL' && o.bullets) {
                    ctx.fillStyle = "#3498db"; o.bullets.forEach(b => { ctx.beginPath(); ctx.arc(b.x,b.y,4,0,Math.PI*2); ctx.fill(); });
                }
            });
        }

        function gameLoop() { 
            if(gameState === 'PLAY') { update(); draw(); animationId = requestAnimationFrame(gameLoop); } 
        }

        function endGame() {
            if(gameState === 'END') return;
            gameState = 'END';
            bgm.pause(); bgm.currentTime = 0; // BGM 중지
            if(animationId) cancelAnimationFrame(animationId);
            spawnTimers.forEach(clearTimeout);
            canvas.style.display = 'none';
            document.getElementById('status-ui').style.display = 'none';
            document.getElementById('result-screen').style.display = 'flex';
            document.getElementById('result-time').innerText = survivedTime + 's';
        }

        window.saveRecord = async function() {
            const name = document.getElementById('username').value.trim() || "익명";
            const btn = document.getElementById('save-btn'); btn.disabled = true;
            try {
                await addDoc(collection(db, "avoidance_rankings"), { name, score: parseFloat(survivedTime), difficulty: diffMode, createdAt: serverTimestamp() });
                document.getElementById('save-btn').innerText = "저장 완료!";
                document.getElementById('retry-btn').style.display = 'block';
            } catch (e) { alert("저장 실패"); btn.disabled = false; }
        }
    </script>
</body>
</html>
